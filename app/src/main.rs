use rocket::{get, http::Status, serde::json::Json};
use serde::Serialize;

#[macro_use]
extern crate rocket;


// The derive "attribute macro" (i.e. any macro that is invoked by an attribute) 
// takes a trait (AKA interface) -- in this case Serialize --
// and figures out how to implement the required methods 
// of the trait for the struct that is defined below the macro
// and adds this implementation to the struct at compile time.
#[derive(Serialize)]
pub struct GenericResponse {
    pub status: String,
    pub message: String,
}

#[get("/")]
pub async fn index() -> Result<Json<GenericResponse>, Status> {
    const MESSAGE: &str = "Hello, world!";

    let response_json = GenericResponse {
        status: Status::Ok.to_string(),
        message: MESSAGE.to_string(),
    };
    // The Serialize trait implementation generated by derive is invoked
    // by Json. It expects a struct that implements Serialize.
    Ok(Json(response_json))
}

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![index,])
}

#[cfg(test)]
mod test {
    use super::rocket;
    use rocket::http::Status;
    use rocket::local::blocking::Client;

    #[test]
    fn test_returns_json() {
        let client = Client::tracked(rocket()).expect("valid rocket instance");
        let response = client.get("/").dispatch();
        assert_eq!(response.status(), Status::Ok);
        assert_eq!(
            response.content_type(),
            Some(rocket::http::ContentType::JSON)
        );
    }
}
